import rospy # фундамент для дрона и ровера
from clover import srv # сервисы для автономного полета
from clover.srv import SetLEDEffect # класс для управления светодиодной ленты
from std_srvs.srv import Trigger # класс типа сообщения Trigger. забей. это надо.
from sensor_msgs.msg import Image # класс типа сообщения Image. для отправки и получения изображений. Формат изображения строго imgmsg (image message)
import math # математика
from aruco_pose.msg import MarkerArray # класс типа сообщения MarkerArray. по сути список, который содержит всю инфу по аруко меткам в зависимости от контекста.
import numpy as np # прокачанные колекции
import cv2 as cv # работа с изображениям. Приоритетный формат изображений - HSV
from cv_bridge import CvBridge # класс, объекты которого могут менять формат изображения.
import imutils # допка для cv, улучшает контуры.

bridge = CvBridge() # объект класса CvBridge. нужен чтоб менять формат изображения.

rospy.init_node('flight') # рос-нода. уникальная. от её имени ты будешь работать с топиками.

get_telemetry = rospy.ServiceProxy('get_telemetry', srv.GetTelemetry) # сервис rospy. получает состояние дрона (координаты, направление, настроение и т.д.)
navigate = rospy.ServiceProxy('navigate', srv.Navigate) # сервис rospy. пермещение по координатам без ожидания конца полета. координаты относительно чего то (аруко карты, мира, самого дрона и т.п.)
set_effect = rospy.ServiceProxy('led/set_effect', SetLEDEffect) # сервис rospy. управляет светодиодной лентой. формат цветов RGB
land = rospy.ServiceProxy('land', Trigger) # сервис rospy. приземление.

latest_markers = MarkerArray() # создаем пустой объект, чтобы не было ошибки, а вообще эта перменнная нужна чтобы от нее получали актуальную инфу по меткам.

parks = [0, 10, 20] # список с id аруко меток, которые являются парковочными местами
free_arucos = set() # сет тех меток, которые дрон сможет увидеть -> а значит они свободны для парковки

flag_led = False # глобальная переменная. флаг который переключает режим светодиодной ленты. False -> значит что цвет устанавливается "вручную" ; True -> цвет устанавливается в зависимости от состояния - дрон видит свободное место, или нет?

colors_led = { # цвета для управления светодиодной лентой в формате RGB
    "Electric Lime": [204, 255, 0],
    "Orchid":        [218, 112, 214],
    "Сrimson":       [220, 20,  60],
    "blue":          [0, 0, 255],
}

colors_detect_hsv = { # цвета, которые дрон должен обнаружить, верний и нижний пределы. в таком формате их удобно использовать в функции: mask = cv.inRange(картинка, <нижний порог цвета>, <верхний порог цвета>)
    'blue': [np.array([110,200,120]), np.array([130,255,255])],
    'red': [np.array([0,100,60]), np.array([10,255,255])],
    'yellow': [np.array([20,200,120]), np.array([40,255,255])],
    'green': [np.array([50,200,120]), np.array([70,255,255])]
}

# дефолтный navigate_wait. дрон летит в указанную точку и останавливает выполнение программы до тех пор, пока не долетит.
def navigate_wait(x = 0 , y = 0, z = 1.5, speed = 0.5, frame_id = "aruco_map", auto_arm = False, tolerance = 0.2):
    navigate(x=x, y=y, z=z, speed=speed, frame_id = frame_id, auto_arm = auto_arm)

    while not rospy.is_shutdown():
        telem = get_telemetry(frame_id = "navigate_target")
        telem_auto = get_telemetry()
        
        if math.sqrt(telem.x ** 2 + telem.y ** 2 + telem.z ** 2) < tolerance:
            rospy.sleep(3)
            break

        rospy.sleep(0.2)

# функция для быстрой установки цвета светодиодной ленты по указанному названию цвета. ориентриует на выше указанный словарь colors_led
def set_led(color):
    # colors_led - словарь с цветами.
    # .get() получает массив из 3 цифр - код RGB указанного цвета
    rgb = colors_led.get(color)
    set_effect(r = rgb[0], g = rgb[1], b = rgb[2], effect = 'fill')
    # синтаксис - set_effect(r, g, b, effect)
    # R, G, B - красный, зеленый, синий
    # effect - тип освещения (fill - просто заполнить одним цветом)
    # rgb[индекс] получает соответственно R, G или B

# эта функция вызывается почти каждый тик. она получает на вход все распознанные маркеры и сохраняет их в глобльную перменную для других функций.
def markers_callback(data):
    global latest_markers # глобальная перменная, которая всегда должна содержать актуальную информацию об обнаруженных маркерах
    latest_markers = data # глобальная перменная обновляется полученными данными

# эта функция вызывается почти каждый тик. она получает на вход картинку с камеры, обрабатывает ее с помощью библиотеки cv и данных маркеров, а потом сохраняет отрисованный результат в топик.
def image_callback(data):
    global latest_markers # глобальная перменная с маркерами

    #кусок кода отвечающий за отрисовку контуров
    cv_image = bridge.imgmsg_to_cv2(data, 'bgr8') # конвертируем полученный imgmsg в указанный формат BGR
    img_hsv = cv.cvtColor(cv_image, cv.COLOR_BGR2HSV) # конвертируем полученный BGR в указанный формат HSV (и нет. сразу из imgmsg в HSV нельзя.)
    for name, color in colors_detect_hsv.items(): # проверям кадр на наличие каждого указанного цвета. 
        contours = get_contours(img_hsv, color) # получить контуры объектов указанного цвета на изображении (get_contours - самописная, см. ниже)
        for contour in contours: # проверяем каждый найденный контур
            area = cv.contourArea(contour) # получаем площадь контура
            if area > 100: # если он дастоточно большой, то
                cv.drawContours(cv_image, [contour], -1, (0,0,0), 5) # рисуем контуры. синтаксис - cv.drawContours(изображение, контуры, индекс контура, (цвет B, G, R), толщина). если указать индекс -1 -> нарисует все контуры
                cv.drawContours(cv_image, [contour], -1, (255,255,255), 2) # второй раз, другим цветом и толщины для эстетики и чтоб точно было видно на картинке.
    # итого на картинке cv_image, в формате BGR отрисованы контуры объектов, указанных цветов.

    # кусок кода отвечающий за логику светодиодной ленты
    led = False # переменная которая будет содрежать итоговый ответ на вопрос "видит ли дрон аруко метку, которая является парковочным местом?"
    for marker in latest_markers.markers: # берем latest_markers (содержит подробную информацию о всех обнаруженных маркерах. формат MarkerArray) и получаем из него список маркеров (через .markers) и проходимся по каждому маркеру с помощью цикла
        id = marker.id # получаем уникальный id маркера
        free_arucos.add(id) # добавляем его в сет свободных маркеров, так как дрон смог его увидеть
        if id in parks: # если маркер является парковочным местом, то
            led = True # дрон видит парковочное место
            c1, c2, c3, c4 = marker.c1, marker.c2, marker.c3, marker.c4 # получаем координаты пикселей для углов аруко метки. 4 переменных, на каждый угол этого квадрата. каждая перменная содержит координаты x и y, соответствующие пикселю на кадре. это будет полезно чтобы отрисовать свободное парковочное место.

            # вычисляем насколько большая аруко метка, которую увидел дрон, чтобы нарисовать рамку соответствующего размера
            x_stp = int(c4.x - c1.x) 
            y_stp = int(c1.y - c2.y)

            # рисуем прямоугольник свободного парковочного места. синтаксис - cv.rectangle(изображение, (угол 1 x, y), (противоположный угол x, y), (цвет R, G, B), толщина)
            cv.rectangle(cv_image, (int(c1.x) - x_stp, int(c1.y) + 2 * y_stp), (int(c3.x) + x_stp, int(c3.y) - 2 * y_stp), (0,255,0), 6)

    # устанавливаем цвет светодиодной ленты
    if flag_led: # если "ручная настройка" позволяет нам установить цвет светодиодной ленты
        if led: # если дрон видит свободное парковочное место
            set_led("Сrimson") # установить цвет светодиодной ленты
        else: 
            set_led("Orchid") # установить цвет светодиодной ленты

    # публикуем изображение в топик
    # но перед этим конвертируем изображение в подходящий формат. из BGR в imgmsg
    image_pub.publish(bridge.cv2_to_imgmsg(cv_image, 'bgr8'))

# функция для получения контуров объектов указанного цвета на изображении
def get_contours(frame, color):
    mask = cv.inRange(frame, color[0], color[1]) # функция cv.inRange выделяет цвета в заданном диапазоне на изображении и возвращает маску (изображение которое содержит только абсолютно черные и абсолютно белые пиксели) на котрой указанны только те пиксели, которые попали в диапазон
    contours = cv.findContours(mask, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE) # по данной маске находит контуры. метод cv.findContours возврщает список всех найденых.
    contours = imutils.grab_contours(contours) # imutils помогает извлечь правильный набор контуров не зависимо от версии библиотеки openCV
    return contours # возвращаем контуры

# функция которая расчитывает координаты аруко метки, основываясь на её id 
# [ВАЖНО изменить её если карта аруко меток изменится]
def get_coords_by_aruco(aruco):
    return aruco % 10, 9 - aruco // 10

# главная функция. описывает повдение дрона, вызывается один раз после всего.
def main():
    global flag_led # глобальная переменная которая переключает режим светодиодной ленты
    flag_led = False # устанавливаем ее в Flase -> сейчас устанавливаем цвет светодиодной ленты "вручную"
    set_led("Electric Lime") # "вручную" ставим цвет, который соответсвует взлету
    navigate_wait(z=1.5, speed = 1, frame_id="body", auto_arm=True) # полет на 1 метр вверх, относительно самого себя. взлёт
    flag_led = True # отдаем управление светодиодной лентой программе
    navigate_wait(z=1.5, y = 10, x = 0, speed = 1, frame_id="aruco_map", auto_arm=True) # полет на другой конец парковки
    navigate_wait(z=1.5, y = 0, x = 0, speed = 1, frame_id="aruco_map", auto_arm=True) # полет обратно
    flag_led = False # устанавливаем цвет светодиодной ленты "вручную"
    set_led("blue") # "вручную" ставим цвет, который соответствует приземелению
    land() # приземление
    
    # кусок кода отвечающий за запись отчета в файл
    file = open("Search_Kuzovnikov_Danil.txt", "w") # открываем файл
    for p in parks: # анализируем каждое парковочное место
        if p in free_arucos: # если парковочное место есть в списке свободных, то
            place = "free" # устанавливаем перменную сообщения в free
        else:
            place = "busy" # устанавливаем перменную сообщения в busy
        x, y = get_coords_by_aruco(p) # получаем координаты аруко метки по её id
        file.write(f"Mesto {p//10+1}: {x} {y}, {place}\n") # формируем строку на основе полученных данных и записываем её в файл 
        # p//10+1 - это короткая формула для вычисления номера парковочного места по id аруко метки. 
        # [ВАЖНО изменить её если карта аруко меток изменится]
    file.close() # закрываем файл

image_sub = rospy.Subscriber('/main_camera/image_raw', Image, image_callback) # подписчик, который постоянно получает изображение камеры и вызывает функцию image_callback
image_pub = rospy.Publisher('/Kuzovnikov_Danil_debug', Image, queue_size=1) # публикатор, который постоянно отправляет обработанное изображение в топик
markers_sub = rospy.Subscriber('/aruco_detect/markers', MarkerArray, markers_callback) # подписчик, который постоянно получает список обнаруженных маркеров и всю информацию по ним

main() # вызываем главную функцию.
  